#!/bin/bash

# Documentation Coverage Checker
# Checks if all public classes and methods have corresponding markdown documentation

# Configuration
JAVA_SOURCE_DIR="src/main/java/org/openpatch/scratch"
DOCS_DIRS=("docs/en/book/reference" "docs/de/book/reference")
PACKAGE_PREFIX="org.openpatch.scratch"

# Command line flag for creating missing files
CREATE_MISSING=false
if [[ "$1" == "--create" || "$1" == "-c" ]]; then
    CREATE_MISSING=true
    echo "CREATE MODE: Will create missing documentation files"
    echo ""
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Counters
total_classes=0
documented_classes=0
total_methods=0
documented_methods=0
missing_docs=()

echo "Documentation Coverage Checker"
echo "=============================="
echo "Java Source: $JAVA_SOURCE_DIR"
echo "Docs Dirs: ${DOCS_DIRS[*]}"
echo ""

# Function to extract class name from file path
get_class_name() {
    local file_path="$1"
    basename "$file_path" .java
}

# Function to create missing method documentation
create_method_documentation() {
    local java_file="$1"
    local method_name="$2"
    local class_name=$(get_class_name "$java_file")
    local doc_folder=$(get_doc_folder "$java_file")

    # Create method documentation in all docs directories
    for docs_dir in "${DOCS_DIRS[@]}"; do
        local doc_path="$docs_dir/$doc_folder/$method_name.md.json"
        local doc_dir_path="$docs_dir/$doc_folder"

        # Create directory if it doesn't exist
        mkdir -p "$doc_dir_path"

        # Create method documentation file
        cat >"$doc_path" <<EOF
{
  "template": "construction",
  "class": "$class_name",
  "name": "$method_name"
}
EOF
        echo -e "    ${GREEN}Created:${NC} $doc_path"
    done
}

# Function to create missing class documentation
create_class_documentation() {
    local java_file="$1"
    local class_name=$(get_class_name "$java_file")
    local doc_folder=$(get_doc_folder "$java_file")

    # Create class documentation in all docs directories
    for docs_dir in "${DOCS_DIRS[@]}"; do
        local doc_dir_path="$docs_dir/$doc_folder"
        local index_file="$doc_dir_path/index.md.yml"

        # Create directory if it doesn't exist
        mkdir -p "$doc_dir_path"

        # Create class index file
        cat >"$index_file" <<EOF
template: "class"
name: "$class_name"
EOF
        echo -e "  ${GREEN}Created:${NC} $index_file"
    done
}
is_public_class() {
    local java_file="$1"
    local class_name=$(get_class_name "$java_file")

    # Check if the class is declared as public
    grep -q "^\s*public\s\+class\s\+$class_name" "$java_file" ||
        grep -q "^\s*public\s\+interface\s\+$class_name" "$java_file" ||
        grep -q "^\s*public\s\+enum\s\+$class_name" "$java_file" ||
        grep -q "^\s*public\s\+abstract\s\+class\s\+$class_name" "$java_file"
}
get_qualified_class_name() {
    local java_file="$1"

    # Extract the relative path from the source directory
    local relative_path="${java_file#$JAVA_SOURCE_DIR/}"

    # Remove the .java extension
    relative_path="${relative_path%.java}"

    # Convert path separators to dots for qualified name
    echo "$PACKAGE_PREFIX.$(echo "$relative_path" | tr '/' '.')"
}

# Function to convert full class path to documentation folder path
get_doc_folder() {
    local java_file="$1"

    # Extract the relative path from the source directory
    local relative_path="${java_file#$JAVA_SOURCE_DIR/}"

    # Remove the .java extension
    relative_path="${relative_path%.java}"

    # Split path into components and convert each to kebab-case
    local doc_path=""
    IFS='/' read -ra path_parts <<<"$relative_path"

    for part in "${path_parts[@]}"; do
        # Convert each part from CamelCase to kebab-case
        kebab_part=$(echo "$part" | sed 's/\([A-Z]\)/-\L\1/g' | sed 's/^-//' | tr '[:upper:]' '[:lower:]')

        if [ -z "$doc_path" ]; then
            doc_path="$kebab_part"
        else
            doc_path="$doc_path/$kebab_part"
        fi
    done

    echo "$doc_path"
}

# Function to extract public methods from Java file
extract_public_methods() {
    local java_file="$1"
    local class_name=$(get_class_name "$java_file")

    # Extract public methods using grep and sed, excluding constructors
    # This regex looks for public methods, excluding constructors and class/interface/enum declarations
    grep -n "^\s*public\s\+.*(" "$java_file" |
        grep -v "class\|interface\|enum" |
        grep -v "^\s*[0-9]*:\s*public\s\+$class_name\s*(" |
        sed -E 's/.*public\s+[^(]*\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(.*/\1/' |
        grep -v "^$" |
        sort -u
}

# Function to check if documentation exists for a method
check_method_documentation() {
    local java_file="$1"
    local method_name="$2"
    local doc_folder=$(get_doc_folder "$java_file")

    # Check in all documentation directories
    for docs_dir in "${DOCS_DIRS[@]}"; do
        local doc_path="$docs_dir/$doc_folder/$method_name.md.json"

        # First check if method documentation exists directly in class folder
        if [ -f "$doc_path" ]; then
            return 0
        fi

        # For specific classes (Sprite, Stage, Window), also check subfolders
        local class_name=$(get_class_name "$java_file")
        if [[ "$class_name" == "Sprite" || "$class_name" == "Stage" || "$class_name" == "Window" ]]; then
            # Check common subfolders for these classes
            local subfolders=("events" "looks" "motion" "sensing" "sound" "control" "operators" "variables")

            for subfolder in "${subfolders[@]}"; do
                local subfolder_path="$docs_dir/$doc_folder/$subfolder/$method_name.md.json"
                if [ -f "$subfolder_path" ]; then
                    return 0
                fi
            done
        fi
    done

    return 1
}

# Function to check if documentation exists for a class
check_class_documentation() {
    local java_file="$1"
    local doc_folder=$(get_doc_folder "$java_file")

    # Check in all documentation directories
    for docs_dir in "${DOCS_DIRS[@]}"; do
        local doc_dir="$docs_dir/$doc_folder"
        if [ -d "$doc_dir" ]; then
            return 0
        fi
    done

    return 1
}

# Main processing
echo "Checking documentation coverage..."
echo ""

# Find all Java files in the source directory (excluding internal package and package-info)
while IFS= read -r -d '' java_file; do
    # Skip files in the internal package
    if [[ "$java_file" == *"/internal/"* ]]; then
        continue
    fi

    # Skip package-info.java files
    if [[ "$java_file" == *"package-info.java" ]]; then
        continue
    fi

    # Skip non-public classes
    if ! is_public_class "$java_file"; then
        continue
    fi
    class_name=$(get_class_name "$java_file")
    qualified_name=$(get_qualified_class_name "$java_file")
    ((total_classes++))

    echo "Processing class: $qualified_name"

    # Check if class has documentation folder
    if check_class_documentation "$java_file"; then
        ((documented_classes++))
        echo -e "  ${GREEN}✓${NC} Class folder exists"
    else
        echo -e "  ${RED}✗${NC} Missing class folder: $(get_doc_folder "$java_file")"
        missing_docs+=("CLASS: $qualified_name -> $(get_doc_folder "$java_file")/")

        # Create missing class documentation if flag is set
        if [ "$CREATE_MISSING" = true ]; then
            create_class_documentation "$java_file"
        fi
    fi

    # Extract and check public methods
    methods=$(extract_public_methods "$java_file")

    if [ -n "$methods" ]; then
        while IFS= read -r method; do
            if [ -n "$method" ]; then
                ((total_methods++))
                echo "  Checking method: $method"

                if check_method_documentation "$java_file" "$method"; then
                    ((documented_methods++))
                    echo -e "    ${GREEN}✓${NC} Documentation exists"
                else
                    echo -e "    ${RED}✗${NC} Missing documentation"
                    doc_folder=$(get_doc_folder "$java_file")
                    class_name=$(get_class_name "$java_file")

                    # Provide helpful suggestion for Sprite, Stage, Window classes
                    if [[ "$class_name" == "Sprite" || "$class_name" == "Stage" || "$class_name" == "Window" ]]; then
                        missing_docs+=("METHOD: $qualified_name.$method -> $doc_folder/$method.md.json (or in subfolders: events/, looks/, motion/, etc.)")
                    else
                        missing_docs+=("METHOD: $qualified_name.$method -> $doc_folder/$method.md.json")
                    fi

                    # Create missing method documentation if flag is set
                    if [ "$CREATE_MISSING" = true ]; then
                        create_method_documentation "$java_file" "$method"
                    fi
                fi
            fi
        done <<<"$methods"
    fi

    echo ""

done < <(find "$JAVA_SOURCE_DIR" -name "*.java" -type f -print0)

# Summary
echo "=============================="
echo "SUMMARY"
echo "=============================="
echo "Classes: $documented_classes/$total_classes documented"
echo "Methods: $documented_methods/$total_methods documented"

if [ ${#missing_docs[@]} -gt 0 ]; then
    echo ""
    if [ "$CREATE_MISSING" = true ]; then
        echo -e "${GREEN}CREATED MISSING DOCUMENTATION FILES${NC}"
        echo "===================================="
        echo -e "${GREEN}Created ${#missing_docs[@]} missing documentation files!${NC}"
        echo ""
        echo "Note: All created files use template placeholders."
        echo "Please review and update the content as needed."
    else
        echo -e "${RED}MISSING DOCUMENTATION:${NC}"
        echo "======================="
        for missing in "${missing_docs[@]}"; do
            echo -e "${YELLOW}$missing${NC}"
        done
        echo ""
        echo -e "${RED}Total missing: ${#missing_docs[@]}${NC}"
        echo ""
        echo "To create missing files automatically, run with --create flag:"
        echo "  $0 --create"
    fi

    if [ "$CREATE_MISSING" = false ]; then
        exit 1
    fi
else
    echo ""
    echo -e "${GREEN}All public classes and methods are documented! ✓${NC}"
    exit 0
fi
